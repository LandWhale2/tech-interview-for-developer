### 간단 일일공부 (19.07.26)

---

#### TCP의 서버와 클라이언트 함수 호출 순서

- **서버** : socket() - bind() - listen() - accept() - read/write() - close()

- **클라이언트** : socket() - connect() - read/write() - close

> 서버는 listen 호출 후 연결요청 대기 큐를 만듬. 그 이후에 클라이언트가 연결 요청 가능
>
> 이때 accept를 호출할 수 있고, 그 전까지는 호출된 위치에서 블로킹 상태

##### TCP 장점

> 이처럼 **연결지향적**인 TCP는 **신뢰성있는 데이터 전송**이 가능 (3-way 핸드쉐이킹)
>
> 흐름제어와 혼잡제어 지원해서 **데이터 순서 보장**해줌
>
> **흐름제어** : 송/수신측 데이터 처리 속도 차이 조절
>
> **혼잡제어** : 네트워크 내 피킷 수가 넘치게 증가하지 않도록 방지

##### TCP 단점

> 정확성 높은 전송을 위해 속도가 느림

**TCP 사용** : WEB HTTP 통신, EMAIL/FILE 전송

<br>

#### 3-way handshaking이란?

> TCP 소켓은 연결 설정과정 중에 총 3번의 대화를 주고 받는다.
>
> (SYN : 연결 요청 플래그 / ACK : 응답)
>
> - 클라이언트는 서버에 접속 요청하는 SYN(M) 패킷을 보냄
> - 서버는 클라이언트 요청인 SYN(M)을 받고, 클라이언트에게 요청을 수락한다는 ACK(M+1)와 SYN(N)이 설정된 패킷을 발송함
> - 클라이언트는 서버의 수락 응답인 ACK(M+1)와 SYN(N) 패킷을 받고, ACK(N+1)를 서버로 보내면 연결이 성립됨
> - 클라이언트가 연결 종료하겠다는 FIN 플래그를 전송함
> - 서버는 클라이언트의 요청(FIN)을 받고, 알겠다는 확인 메시지로 ACK를 보냄. 그 이후 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 됨
> - 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송함
> - 클라이언트는 FIN 메시지를 확인했다는 ACK를 보냄
> - 클라이언트의 ACK 메시지를 받은 서버는 소켓 연결을 close함
> - 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해서, 일정 시간동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거침 ( TIME_WAIT )

<br>

#### UDP

> TCP의 대안이며, 마찬가지로 실제 데이터 단위를 받기 위해 IP를 사용함
>
> TCP와는 달리 메시지를 패킷으로 나누거나 재조립하는 서비스 제공X
>
> 여러 컴퓨터를 거치지 않고 데이터를 주고받을 컴퓨터끼리 직접 연결할 때 사용

UDP로 목적지(IP)로 메시지를 보낼 수 있으며, 컴퓨터를 거쳐 목적지까지 도달할 수도, 않을 수도 있음

정보 받는 컴퓨터는 포트를 열어두고, 패킷이 올 때까지 기다리며 오는 데이터를 모두 다 받아들임

패킷이 도착했을 때 출발지에 대한 IP와 PORT를 알 수 있음

따라서 UDP는 비신뢰적이고 안정적이지 못한 프로토콜임. 하지만 속도가 매우 빠르고 편하기 때문에 데이터 유실이 일어나도 큰 상관없는 스트리밍이나 화면 전송에 사용