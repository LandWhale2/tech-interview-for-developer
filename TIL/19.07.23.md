### 간단 일일공부 (19.07.23)



#### 이진탐색 (Binary Search)

---

> 쉽게 말해, 탐색의 대상을 반으로 분할하고~분할하고~분할해서 원하는 값을 탐색하는 방법
>
> 반으로 분할하는 과정은 **순차탐색보다 좋은 성능**을 보인다.

<br>

**조건** : 배열(리스트)가 반드시 정렬된 상태로 저장되어있어야 사용이 가능함

정렬과정에서 중간 값을 확인하기 위한 분할을 진행하는데, 정렬이 안되있으면 말짱도루묵..

```
ex) [1, 2, 3, 4, 5, 6] 배열에서 5를 찾아야 함
1. 중간값을 선택한다. (중간값은 6/2 = 3)
2. 찾을값(5)과 중간값(3) 비교. 중간값보다 크면 오른쪽 구간에서 중간값 다시 선택하고 작으면 왼쪽 구간에서 중간값 다시 선택
3. 중간값보다 크므로, 오른쪽 구간에서 다시 시작. 오른쪽 구간은 [4,5,6]이므로 중간값은 5임. 찾을값과 일치하므로 탐색 종료
```

이처럼 이진탐색은 순차탐색을 하면 5번 만에 찾을 '5'의 값을 훨씬 빠르게 탐색할 수 있다! 

<br>

```java
public static int binarySearch(int[] array, int key) {
    int low = 0;
    int high = array.length - 1;
    
    while(low <= high) {
        int mid = (low + high) / 2;
        int midVal = array[mid];
        
        if(midVal < key) low = mid + 1;
        else if (midVal > key) high = mid - 1;
        else return mid; // 찾은 경우
    }
    return -(low+1); // 찾지 못한 경우
}
```

<br>

<br>

#### 이진 검색 트리(Binary Search Tree)

> 각 노드의 자식이 2개 이하인 트리
>
> 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 큼

<br>

##### 노드 삽입 시간

---

**균등 트리** : 노드 개수 N개일 때 O(logN)

**편향 트리** : 노드 개수 N개일 때 O(N)

삽입,검색,삭제의 시간복잡도는 트리 **높이**에 비례함

<br>

삭제가 조금 까다로움 (3가지 case)

- 자식이 없는 leaf 노드면? → 그냥 지우면 끝
- 자식이 1개인 노드면? → 지워진 노드에 자식을 올리면 끝
- 자식이 2개인 노드면?
  - 자식 노드 중에서 삭제할 노드보다 크면서 가장 작은 값
  - 자식 노드 중에서 삭제할 노드보다 작으면서 가장 큰 값

편향된 트리(ex. 정렬된 상태인 값을 트리로 만들면 한쪽으로 뻗는다)에서는 시간복잡도가 O(N)이 되므로 트리를 사용하는 이유가 사라짐

편향된 트리를 바로잡도록 삽입,삭제를 개선한 트리 → AVL Tree, RedBlack Tree

<br>