### 간단 일일공부 (19.07.31)

------

### PWA (Progressive Web App)

> 웹의 장점과 앱의 장점을 결합한 환경
>
> `앱 수준과 같은 사용자 경험을 웹에서 제공하는 것이 목적!`

#### 특징

확장성이 좋고, 깊이 있는 앱같은 웹을 만드는 것을 지향한다.

웹 주소만 있다면, 누구나 접근하여 사용이 가능하고 스마트폰의 저장공간을 잡아 먹지 않음

**서비스 작업자(Service Worker) API** : 웹앱의 중요한 부분을 캐싱하여 사용자가 다음에 열 때 빠르게 로딩할 수 있도록 도와줌

→ 네트워크 환경이 좋지 않아도 빠르게 구동되며, 사용자에게 푸시 알림을 보낼 수도 있음

<br>

#### PWA 제공 기능

- 프로그래시브 : 점진적 개선을 통해 작성되서 어떤 브라우저든 상관없이 모든 사용자에게 적합
- 반응형 : 데스크톱, 모바일, 테블릿 등 모든 폼 factor에 맞음
- 연결 독립적 : 서비스 워커를 사용해 오프라인에서도 작동이 가능함
- 안전 : HTTPS를 통해 제공이 되므로 스누핑이 차단되어 콘텐츠가 변조되지 않음
- 검색 가능 : W3C 매니페스트 및 서비스 워커 등록 범위 덕분에 '앱'으로 식별되어 검색이 가능함
- 재참여 가능 : 푸시 알림과 같은 기능을 통해 쉽게 재참여가 가능함

<br>

<br>

### 페이지 교체 알고리즘

> 페이지의 부재가 발생하면? 새로운 페이지를 할당해야한다. 현재 할당된 페이지 중에서 어떤 페이지를 교체할지 결정해야함

<br>

가상 메모리는 `요구 페이징 기법`을 통해 필요한 페이지만 메모리에 적재한다.

하지만 필요한 페이지만 넣은 메모리도 가득차면?

> 필요해서 올려둔 페이지 중 사용이 끝나 자리만 차지하는 녀석을 빼줘야 한다.

이때 out하는 페이지를 victim page라고 부르고, 그 자리에 필요한 페이지를 in한다.

<br>

out 페이지는 되도록이면 앞으로 수정되지 않는 페이지를 선택해야 한다.

(왜냐하면, 수정되면 Main 메모리에서 내보낼 때 하드디스크에서 또 수정과정을 거쳐야함)

<br>

이때 사용하는 것이 바로 `페이지 교체 알고리즘`이다.

우선, 참조열을 만드는 Page Reference String에 대해 알아보자

> CPU는 논리 주소를 통해 특정 주소를 요구하는데, 메인메모리에 올라와 있는 주소들은 페이지 단위로 가져오기 때문에 페이지 번호가 연속적이면 결함이 발생하지 않는다.

```
CPU 요구 주소 : 100, 101, 102, 432, 612, 103, 104, 611, 612
페이지 사이즈 : 100

페이지 번호 : 1, 1, 1, 4, 6, 1, 1, 6, 6
Page Reference String : 1, 4, 6, 1, 6
```

이처럼 같은 페이지 단위에 들어가는 주소들을 생략하여 참조열을 구성하고, 페이지 교체 알고리즘을 진행하게 된다.

<br>

1. FIFO 알고리즘

   > 먼저 올라온 건 먼저 내보낸다. (가장 간단)
   >
   > 초기화 코드에 사용한다. (처음 프로세스를 실행할 때만 필요하고 사용하지 않는 것들)

2. OPT 알고리즘

   > 앞으로 가장 사용하지 않을 페이지를 먼저 내보낸다.
   >
   > 가장 좋은 효과를 가져올 수 있지만 실제로 적용하기엔 불가능에 가까운 알고리즘

3. LRU 알고리즘

   > 최근에 사용하지 않은 페이지를 가장 먼저 내보낸다.
   >
   > (최근에 사용하지 않았으면 앞으로도 사용하지 않을 확률이 높음)
   >
   > 셋 중에 실제로 가장 효율적으로 사용할 수 있는 교체 알고리즘